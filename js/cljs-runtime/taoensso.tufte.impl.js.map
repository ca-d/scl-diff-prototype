{"version":3,"sources":["taoensso/tufte/impl.cljc"],"mappings":"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","names":["this__5287__auto__","writer__5288__auto__","opt__5289__auto__","cljs.core/-write","taoensso.tufte.impl/Time","taoensso.tufte.impl/->Time","id","t","location-info","taoensso.tufte.impl/TimeSpan","taoensso.tufte.impl/->TimeSpan","t0","t1","cljs.core/deref","taoensso.tufte.impl/PStats","taoensso.tufte.impl/->PStats","pd","tspans","realized_","_","cljs.core/realized?","taoensso.tufte.impl/PState","taoensso.tufte.impl/->PState","acc","id-times","id-sstats","taoensso.tufte.impl/PData","taoensso.tufte.impl/->PData","nmax","pstate_","this","taoensso.tufte.impl/deref-pdata","taoensso.tufte.impl/new-pdata-local","taoensso.encore/now-nano","cljs.core/volatile!","taoensso.tufte.impl/new-pdata-dynamic","cljs.core.atom","cljs.core/List","cljs.core/Delay","taoensso.tufte.impl/deref-pstats","taoensso.tufte.impl/*pdata*","stack","pdata_","taoensso.tufte.impl/pdata-local-get","taoensso.tufte.impl/pdata-local-pop","temp__5802__auto__","stashed","cljs.core/vreset!","taoensso.tufte.impl/pdata-local-push","v","to-stash","taoensso.tufte.impl/ElapsedTimeAcc","taoensso.tufte.impl/->ElapsedTimeAcc","tsum","max-t1","sort-tspans","cljs.core.sort_by","tspan","taoensso.tufte.impl/tspans->tsum","cljs.core/empty?","sorted-tspans","cljs.core.reduce","Math/max","taoensso.tufte.impl/fast-into","c0","c1","cljs.core/count","cljs.core.into","taoensso.tufte.impl/merge-tspans","tspans0","tspans1","tspans2","taoensso.tufte.impl/times-into-id-times","to-id-times","from-times","cljs.core/not-empty","taoensso.encore/force-ref","cljs.core/persistent!","m","in","loc","id*","cljs.core.assoc_BANG_","cljs.core.conj","cljs.core.get","cljs.core/transient","or__5002__auto__","pstate","public-stats-output","id*-sstats_","id*-loc_","cljs.core/reduce-kv","times","vec__16481","cljs.core.nth","sstats<times","taoensso.tufte.stats.summary_stats","sstats-merged","taoensso.tufte.stats/summary-stats-merge","new-id*-sstats","old","taoensso.tufte.stats.summary_stats_merge","new-id*-loc","cljs.core/set?","cljs.core._EQ_","new-id*-entry","cljs.core.assoc","taoensso.tufte.impl/merge-sstats-when-needed","sstats","var_args","G__16485","taoensso.tufte.impl/merge-pstats","js/Error","ps0","ps1","taoensso.tufte.impl.merge_pstats","vec__16486","pd0","pd1","cljs.core/long","pd0-t0","ps0-t1","pd1-t0","ps1-t1","pd2-t0","ps2-t1","pd0-pstate","pd1-pstate","pd0-id-times","pd1-id-times","pd0-id-sstats","pd1-id-sstats","pd2-ids","cljs.core/keys","pd2-id-times","pd2-id-sstats","p__16489","vec__16490","pd0-times","pd0-sstats","pd1-times","pd1-sstats","pd2-times","pd2-sstats","pd2","taoensso.tufte.impl/capture-time!","ns-elapsed","cljs.core/Atom","new-time","?pulled-times","old-times","new-times","cljs.core/compare-and-set!","temp__5804__auto__","cljs.core.swap_BANG_","taoensso.tufte.impl/compact-pstate","pulled-times","dynamic?","vec__16493","vec__16496","new-acc","js/taoensso","js/taoensso.tufte","js/taoensso.tufte.impl","js/taoensso.tufte.impl.handlers_","taoensso.tufte.impl/handlers_","taoensso.tufte.impl/handle-blocking!","taoensso.encore/run-kv!","f","e16499","e","e16500","cljs.core.println","taoensso.tufte.impl/handle!"],"sourcesContent":["(ns ^:no-doc taoensso.tufte.impl\n  \"Private implementation details.\n  `profiled` -> [<result> <derefable-and-mergeable-pstats>].\n\n  Profiling consists of:\n    1. State init   ; On  thread\n    2. Capture      ; On  thread\n    3. State deref  ; On  thread\n    4. ?Merging     ; Off thread, on demand (deferred cost)\n    5. ?Realization ; Off thread, on demand (deferred cost)\n\n  Basic implementation:\n    - Capture [<id> <elapsed>]s into single mutable acc\n      - May compact acc      to id-times,  {<id> (<time>         ...)}\n      - May compact id-times to id-sstats, {<id> (<stats/sstats> ...)}\n    - Merge pours (read-only) acc0 + acc1 into id-times\n      - May compact id-times to id-sstats, {<id> (<stats/sstats> ...)}\n    - Realization:\n        - Generates {<id> <stats/sstats>} from id-times.\n        - Merges with id-sstats.\"\n\n  (:require\n   [clojure.string  :as str]\n   [taoensso.encore :as enc :refer-macros []]\n   [taoensso.tufte.stats :as stats])\n\n  #?(:clj\n     (:import [java.util LinkedList Stack]\n              [java.util.concurrent ArrayBlockingQueue]))\n\n  #?(:cljs\n     (:require-macros\n      [taoensso.tufte.impl :refer [mt-acc mt-add mt-count atom?]])))\n\n;;;; Mutable accumulators\n\n(deftype Time     [id ^long t location-info])\n(deftype TimeSpan [^long t0 ^long t1])\n(comment (enc/qb 1e6 (Time. :foo 1000 nil))) ; 33.59\n\n#?(:clj\n   (do\n     (defmacro ^:private mt-acc     [] `(enc/if-cljs (cljs.core/array) (LinkedList.)))\n     (defmacro ^:private mt-add [mt x] `(enc/if-cljs (.push   ~mt ~x) (.add  ~(with-meta mt {:tag 'LinkedList}) ~x)))\n     (defmacro ^:private mt-count [mt] `(enc/if-cljs (alength ~mt)    (.size ~(with-meta mt {:tag 'LinkedList}))))))\n\n(comment (enc/qb 1e6 (mt-acc) (atom nil))) ; [29.14 57.76]\n\n;;;; PStats (Profiling Stats)\n;; API-level state we'll return from `profiled`: derefable, mergeable\n\n(deftype PStats [pd ^long t1 tspans realized_]\n  #?@(:clj  [clojure.lang.IDeref    (deref     [_]           @realized_)]\n      :cljs [             IDeref   (-deref     [_]           @realized_)])\n  #?@(:clj  [clojure.lang.IPending (isRealized [_] (realized? realized_))]\n      :cljs [             IPending (-realized? [_] (realized? realized_))]))\n\n;;;; PData (Profiling Data)\n;; Implementation-level state while profiling,\n;;   - id-times:  ?{<id> (<time>         ...)}\n;;   - id-sstats: ?{<id> (<stats/sstats> ...)}\n\n(declare ^:private deref-pdata)\n(deftype PState [acc id-times id-sstats])\n(deftype  PData [^long nmax ^long t0 pstate_]\n  #?@(:clj  [clojure.lang.IDeref  (deref [this] (deref-pdata this))]\n      :cljs [             IDeref (-deref [this] (deref-pdata this))]))\n\n(defn new-pdata-local   [^long nmax] (let [t0 (enc/now-nano*)] (PData. nmax t0 (volatile! (PState. (mt-acc)   nil nil)))))\n(defn new-pdata-dynamic [^long nmax] (let [t0 (enc/now-nano*)] (PData. nmax t0 (atom      (PState. (atom nil) nil nil)))))\n\n(comment (enc/qb 1e6 (new-pdata-local 10) (new-pdata-dynamic 10))) ; [98.18 138.28]\n\n(declare ^:private deref-pstats)\n(defn- deref-pdata \"PData->PStats\" [^PData pd]\n  ;; NB (.-acc pd) should never be mutated from this point!\n  (let [t1     (enc/now-nano*)\n        t0     (.-t0 pd)\n        tspans (list (TimeSpan. t0 t1))]\n\n    (PStats. pd t1 tspans (delay (deref-pstats pd t1 tspans)))))\n\n(comment (enc/qb 1e6 @(new-pdata-local 10))) ; 245.08\n\n(def ^:dynamic *pdata* \"nnil iff dynamic profiling active\" nil)\n\n#?(:clj\n   (let [;; Stack to support `profile/d` nesting\n         ^ThreadLocal stack-proxy (proxy [ThreadLocal] [] (initialValue [] (Stack.)))\n         ^ThreadLocal pdata-proxy (proxy [ThreadLocal] [])]\n\n     (defn pdata-local-get [] (.get pdata-proxy)) ; => nnil iff thread-local profiling active\n     (defn pdata-local-pop []\n       (let [^Stack stack (.get stack-proxy)]\n         (if-let [stashed (when-not (.empty stack) (.pop stack))]\n           (do (.set pdata-proxy stashed) stashed)\n           (do (.set pdata-proxy nil)     nil))))\n\n     (defn pdata-local-push [v]\n       (let [^Stack stack  (.get stack-proxy)]\n         (if-let [to-stash (.get pdata-proxy)]\n           (do (.push stack to-stash) (.set pdata-proxy v) v)\n           (do                        (.set pdata-proxy v) v)))))\n\n   :cljs ; Note single-threaded platform\n   (let [stack #js [] ; To support `profile/d` nesting\n         pdata_ (volatile! false)]\n\n     (defn pdata-local-get [] @pdata_) ; => nnil iff thread-local profiling active\n     (defn pdata-local-pop []\n       (if-let [stashed (.pop stack)]\n         (vreset! pdata_ stashed)\n         (vreset! pdata_ nil)))\n\n     (defn pdata-local-push [v]\n       (if-let [to-stash @pdata_]\n         (do (.push stack to-stash) (vreset! pdata_ v))\n         (do                        (vreset! pdata_ v))))))\n\n(comment\n  (pdata-local-push \"foo\")\n  (pdata-local-pop)\n  (enc/qb 1e6 *pdata* (pdata-local-get)) ; [63.7 48.77]\n  (enc/qb 1e6  ; [507.58 74.62]\n    (binding [*pdata* \"foo\"])\n    (try (pdata-local-push \"foo\") (finally (pdata-local-pop))))\n\n  (do\n    (pdata-local-push \"pd1\")\n    (pdata-local-push \"pd2\")\n    [(let [pd (pdata-local-get)] (pdata-local-pop) pd)\n     (let [pd (pdata-local-get)] (pdata-local-pop) pd)]))\n\n;;;; TimeSpan utils\n\n(deftype ElapsedTimeAcc [^long tsum ^long max-t1])\n(let [sort-tspans (fn [tspans] (sort-by (fn [^TimeSpan tspan] (.-t0 tspan)) tspans))]\n  (defn- tspans->tsum\n    \"Returns `tsum` (elapsed time) given collection of `TimeSpan`s.\n    Based on https://codereview.stackexchange.com/a/126927.\"\n    ^long [tspans]\n    (if (empty? tspans)\n      0\n      (let [sorted-tspans (sort-tspans tspans)] ; O(n.logn)\n        (.-tsum ^ElapsedTimeAcc\n          (reduce\n            (fn [^ElapsedTimeAcc acc ^TimeSpan tspan]\n              (let [t1     (.-t1     tspan)\n                    max-t1 (.-max-t1 acc)]\n                (if (> t1 max-t1)\n                  (let [t0   (.-t0   tspan)\n                        tsum (.-tsum acc)]\n                    (ElapsedTimeAcc. (+ tsum (- t1 (Math/max t0 max-t1))) t1))\n                  acc)))\n            (ElapsedTimeAcc. 0 0)\n            sorted-tspans))))))\n\n(comment\n  (tspans->tsum nil)\n  (tspans->tsum [])\n  (tspans->tsum [(TimeSpan. 1   3) (TimeSpan. 3 6)])\n  (tspans->tsum [(TimeSpan. 3   6) (TimeSpan. 1 3)])\n  (tspans->tsum [(TimeSpan. 1  10) (TimeSpan. 3 6)])\n  (enc/qb 1e6\n    (tspans->tsum\n      [(TimeSpan. 10 14)\n       (TimeSpan.  4 18)\n       (TimeSpan. 19 20)\n       (TimeSpan. 19 20)\n       (TimeSpan. 13 20)])))\n\n(defn- fast-into [c0 c1] (if (> (count c0) (count c1)) (into c0 c1) (into c1 c0)))\n(comment (fast-into nil nil))\n\n(defn- merge-tspans [^long nmax ^long t1 tspans0 tspans1]\n  (let [tspans2 (fast-into tspans0 tspans1)]\n    (if (> (count tspans2) nmax) ; Compact, may lose some accuracy\n      (let [tsum (tspans->tsum tspans2)]\n        (list (TimeSpan. (- t1 tsum) t1)))\n      tspans2)))\n\n(comment\n  (merge-tspans 2 50\n    (list (TimeSpan. 1 10) (TimeSpan. 5  20))\n    (list (TimeSpan. 1 10) (TimeSpan. 20 50))))\n\n;;;;\n\n(defn- times-into-id-times\n  \"NB treats `from-times` as read-only (may be mutable `acc`)!\"\n  [to-id-times from-times]\n  (not-empty\n    (if-let [from-times (enc/force-ref from-times)]\n      (persistent!\n        (reduce\n          (fn [m ^Time in]\n            (let [t   (.-t             in)\n                  id  (.-id            in)\n                  loc (.-location-info in)\n                  id* [id loc]]\n\n              ;; We'll use [id loc] as a pseudo id from here on in\n              ;; order to track location info. We'll then reverse\n              ;; the wrapping on final `deref-pstats`.\n              (assoc! m id* (conj (get m id*) t))))\n\n          (transient (or to-id-times {}))\n          from-times))\n\n      to-id-times)))\n\n(comment\n  (times-into-id-times nil nil)\n  (times-into-id-times {}  nil)\n  (let [mt (mt-acc)]\n    (mt-add mt (Time. :foo 2 nil))\n    (times-into-id-times {:foo '(1)} mt)))\n\n(defn- deref-pstats\n  \"PStats->{:clock _ :stats {<id> <stats/sstats-map>}} (API output)\"\n  [^PData pd ^long t1 tspans]\n  (let [t0      (.-t0      pd)\n        pstate_ (.-pstate_ pd)\n        ^PState pstate (enc/force-ref pstate_)\n        id-times  (.-id-times  pstate)\n        id-sstats (.-id-sstats pstate)\n        id-times  (times-into-id-times id-times (.-acc pstate))\n\n        public-stats-output ; {<id*> <stats/sstats-map>}\n        (when id-times\n          (let [;;; Disposable internal state\n                id*-sstats_ (volatile! (transient {})) ; {<id*>  <sstats>}\n                id*-loc_    (volatile! (transient {})) ; {<id*> <map-or-set>}\n                ]\n\n            (persistent!\n              (reduce-kv\n                (fn [m id times]\n                  (let [[id* loc] id ; Reverse [id loc] wrapping done at `times-into-id-times`\n\n                        sstats<times  (stats/summary-stats times)\n                        sstats-merged (reduce stats/summary-stats-merge sstats<times\n                                        (get id-sstats id))\n\n                        ;; Note that a single id* may have >1 locs and so >1\n                        ;; [id loc] entries in id-times. While uncommon, this is\n                        ;; is sensible and supported.\n\n                        ;; Final sstats merged from all locations for given id*\n                        new-id*-sstats\n                        (if-let [old (get @id*-sstats_ id*)]\n                          (stats/summary-stats-merge old sstats-merged)\n                          (do                            sstats-merged))\n\n                        ;; Location (map or set) for given id*\n                        new-id*-loc\n                        (if-let [old (get @id*-loc_ id*)]\n                          (if (set? old)\n                            (conj old loc)\n                            (if (= old loc) old #{old loc}))\n                          loc)\n\n                        new-id*-entry (assoc @new-id*-sstats :loc new-id*-loc)]\n\n                    (vswap! id*-sstats_ assoc!   id* new-id*-sstats)\n                    (vswap! id*-loc_    assoc!   id* new-id*-loc)\n                    (do                (assoc! m id* new-id*-entry))))\n\n                (transient {})\n                id-times))))]\n\n    {:clock {:t0 t0 :t1 t1 :total (tspans->tsum tspans)}\n     :stats public-stats-output}))\n\n(comment @@(new-pdata-local 10))\n\n(defn- merge-sstats-when-needed [^long nmax sstats]\n  (if (<= (count sstats) nmax)\n    (do                                     sstats)\n    (list (reduce stats/summary-stats-merge sstats))))\n\n(defn merge-pstats \"Compacting merge\"\n  ([     ps0 ps1] (merge-pstats nil ps0 ps1))\n  ([nmax ps0 ps1]\n   (if ps0\n     (if ps1\n       (let [^PStats ps0       ps0\n             ^PStats ps1       ps1\n             ^PData  pd0 (.-pd ps0)\n             ^PData  pd1 (.-pd ps1)\n\n             nmax (long (or nmax (.-nmax pd0)))\n             pd0-t0 (.-t0 pd0)\n             ps0-t1 (.-t1 ps0)\n             pd1-t0 (.-t0 pd1)\n             ps1-t1 (.-t1 ps1)\n\n             pd2-t0  (if (< pd0-t0 pd1-t0) pd0-t0 pd1-t0)\n             ps2-t1  (if (> ps0-t1 ps1-t1) ps0-t1 ps1-t1)\n             tspans2 (merge-tspans nmax ps2-t1 (.-tspans ps0) (.-tspans ps1))\n\n             ^PState pd0-pstate (enc/force-ref (.-pstate_ pd0))\n             ^PState pd1-pstate (enc/force-ref (.-pstate_ pd1))\n\n             pd0-id-times  (times-into-id-times (.-id-times pd0-pstate) (.-acc pd0-pstate))\n             pd1-id-times  (times-into-id-times (.-id-times pd1-pstate) (.-acc pd1-pstate))\n             pd0-id-sstats (.-id-sstats pd0-pstate)\n             pd1-id-sstats (.-id-sstats pd1-pstate)\n\n             ;; All ids in pd0 or pd1\n             pd2-ids (keys (conj (or pd0-id-times {}) pd1-id-times))\n\n             ;; Merge pd1 into pd0 to get pd2\n             [pd2-id-times pd2-id-sstats]\n             (reduce\n               (fn [[pd2-id-times pd2-id-sstats] id]\n                 (let [pd0-times  (get pd0-id-times  id)\n                       pd0-sstats (get pd0-id-sstats id)\n                       pd1-times  (get pd1-id-times  id)\n                       pd1-sstats (get pd1-id-sstats id)\n\n                       pd2-times  (fast-into pd0-times  pd1-times)\n                       pd2-sstats (fast-into pd0-sstats pd1-sstats)]\n\n                   (if (<= (count pd2-times) nmax) ; Common case\n                     [(assoc pd2-id-times  id pd2-times)\n                      (assoc pd2-id-sstats id pd2-sstats)]\n\n                     ;; Times need compaction\n                     (let [sstats<times (stats/summary-stats pd2-times)]\n                       [(assoc pd2-id-times  id nil)\n                        (assoc pd2-id-sstats id\n                          (merge-sstats-when-needed nmax\n                            (conj pd2-sstats sstats<times)))]))))\n\n               [pd0-id-times pd0-id-sstats]\n               pd2-ids)\n\n             pd2 (PData. nmax pd2-t0 (PState. nil pd2-id-times pd2-id-sstats))]\n         (PStats. pd2 ps2-t1 tspans2 (delay (deref-pstats pd2 ps2-t1 tspans2))))\n\n       ps0)\n     ps1)))\n\n;;;; Time capture\n\n#?(:clj\n   (defmacro ^:private atom? [x]\n     `(enc/if-cljs\n        (instance?    cljs.core.Atom ~x)\n        (instance? clojure.lang.Atom ~x))))\n\n(declare ^:private compact-pstate)\n(defn capture-time! [^PData pd id ns-elapsed location-info]\n  (let [nmax    (.-nmax    pd)\n        pstate_ (.-pstate_ pd)\n        ^PState pstate @pstate_\n        acc (.-acc pstate)]\n\n    (if (atom? acc)\n\n      ;; Dynamic profiling\n      (let [new-time (Time. id ns-elapsed location-info)\n            ?pulled-times\n            (loop []\n              (let [old-times @acc\n                    new-times (conj old-times new-time)]\n                (if (<= (count new-times) nmax)\n                  (if (compare-and-set! acc old-times new-times) nil (recur))\n                  (if (compare-and-set! acc old-times nil) new-times (recur)))))]\n\n        (when-let [times ?pulled-times] ; Do compaction, rare\n          (let [t0 (enc/now-nano*)]\n            ;; Contention against `pstate_` unlikely since we just drained `acc`\n            (swap! pstate_ (fn [pstate] (compact-pstate pstate times nmax true)))\n            (recur pd :tufte/compaction (- (enc/now-nano*) t0) nil))))\n\n      (do ; Common case: thread-local profiling\n        (mt-add acc (Time. id ns-elapsed location-info))\n\n        (when (> (mt-count acc) nmax) ; Do compaction, rare\n          (let [t0 (enc/now-nano*)]\n            (vreset! pstate_ (compact-pstate pstate acc nmax false))\n            (recur pd :tufte/compaction (- (enc/now-nano*) t0) nil)))))))\n\n(defn- compact-pstate [^PState pstate pulled-times ^long nmax dynamic?]\n  ;; Note that compaction expense doesn't distort p times unless there's\n  ;; p nesting (where outer p time includes inner p's capture time).\n  (let [id-times  (.-id-times  pstate)\n        id-sstats (.-id-sstats pstate)\n        id-times  (times-into-id-times id-times pulled-times)\n\n        [id-times id-sstats]\n        (reduce-kv\n          (fn [acc id times]\n            (if (<= (count times) nmax)\n              acc\n              (let [[id-times id-sstats] acc\n                    sstats<times (stats/summary-stats times)]\n                [(assoc id-times  id nil)\n                 (assoc id-sstats id\n                   (merge-sstats-when-needed nmax\n                     (conj (get id-sstats id) sstats<times)))])))\n\n          [id-times id-sstats]\n          id-times)\n\n        new-acc (if dynamic? (.-acc pstate) (mt-acc))]\n\n    (PState. new-acc id-times id-sstats)))\n\n(comment\n  (try\n    (pdata-local-push (new-pdata-local 1e7))\n    (enc/qb 1e6 (capture-time! (pdata-local-get) :foo 1 nil))\n    (finally (pdata-local-pop)))) ; 98.35\n\n;;;; Output handlers\n\n(enc/defonce handlers_ \"{<hid> <handler-fn>}\" (atom nil))\n\n#?(:clj\n   (enc/defonce ^:private ^ArrayBlockingQueue handler-queue\n     \"While user handlers should ideally be non-blocking, we'll use a queue\n     here to be safe + make sure we never tie up the execution thread.\"\n     (ArrayBlockingQueue. 1024)))\n\n(defn- handle-blocking! [m]\n  (enc/run-kv!\n    (fn [id f]\n      (enc/catching (f m) e\n        (enc/catching ; Esp. nb for Cljs\n          (println (str \"WARNING: Uncaught Tufte `\" id \"` handler error\\n\" e)))))\n    @handlers_))\n\n#?(:clj  (declare ^:private handler-thread_))\n#?(:cljs (defn handle! [m] (handle-blocking! m) nil))\n#?(:clj  (defn handle! [m] (.offer handler-queue m) @handler-thread_ nil))\n#?(:clj\n   (defonce ^:private handler-thread_\n     (delay\n       (let [f (fn []\n                 (loop []\n                   (let [m (.take handler-queue)]\n                     ;; Note: just drop if no registered handlers\n                     (handle-blocking! m)\n                     (recur))))]\n         (doto (Thread. f)\n           (.setDaemon true)\n           (.start))))))\n"],"x_google_ignoreList":[0]}